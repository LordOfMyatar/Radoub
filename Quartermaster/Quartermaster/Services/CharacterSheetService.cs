using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Radoub.Formats.Bic;
using Radoub.Formats.Utc;

namespace Quartermaster.Services;

/// <summary>
/// Generates character sheet exports in text and markdown formats.
/// </summary>
public class CharacterSheetService
{
    private readonly CreatureDisplayService _displayService;

    public CharacterSheetService(CreatureDisplayService displayService)
    {
        _displayService = displayService;
    }

    /// <summary>
    /// Generates a character sheet in plain text format.
    /// </summary>
    public string GenerateTextSheet(UtcFile creature, string? filePath = null)
    {
        var sb = new StringBuilder();
        var isBic = filePath?.EndsWith(".bic", StringComparison.OrdinalIgnoreCase) ?? false;

        // Header
        sb.AppendLine("═══════════════════════════════════════════════════════════════");
        sb.AppendLine($"  CHARACTER SHEET: {CreatureDisplayService.GetCreatureFullName(creature)}");
        sb.AppendLine("═══════════════════════════════════════════════════════════════");
        sb.AppendLine();

        // Identity Section
        AppendIdentitySection(sb, creature, isBic);

        // Class Progression
        AppendClassSection(sb, creature);

        // Ability Scores
        AppendAbilitySection(sb, creature);

        // Combat Statistics
        AppendCombatSection(sb, creature);

        // Skills
        AppendSkillsSection(sb, creature);

        // Feats
        AppendFeatsSection(sb, creature);

        // Spells (if caster)
        AppendSpellsSection(sb, creature);

        // Equipment
        AppendEquipmentSection(sb, creature);

        // Scripts (UTC only)
        if (!isBic)
        {
            AppendScriptsSection(sb, creature);
        }

        // Footer
        sb.AppendLine("═══════════════════════════════════════════════════════════════");
        sb.AppendLine($"  Generated by Quartermaster on {DateTime.Now:yyyy-MM-dd HH:mm}");
        sb.AppendLine("═══════════════════════════════════════════════════════════════");

        return sb.ToString();
    }

    /// <summary>
    /// Generates a character sheet in markdown format.
    /// </summary>
    public string GenerateMarkdownSheet(UtcFile creature, string? filePath = null)
    {
        var sb = new StringBuilder();
        var isBic = filePath?.EndsWith(".bic", StringComparison.OrdinalIgnoreCase) ?? false;

        // Header
        sb.AppendLine($"# {CreatureDisplayService.GetCreatureFullName(creature)}");
        sb.AppendLine();

        // Identity Section
        AppendIdentitySectionMd(sb, creature, isBic);

        // Class Progression
        AppendClassSectionMd(sb, creature);

        // Ability Scores
        AppendAbilitySectionMd(sb, creature);

        // Combat Statistics
        AppendCombatSectionMd(sb, creature);

        // Skills
        AppendSkillsSectionMd(sb, creature);

        // Feats
        AppendFeatsSectionMd(sb, creature);

        // Spells (if caster)
        AppendSpellsSectionMd(sb, creature);

        // Equipment
        AppendEquipmentSectionMd(sb, creature);

        // Scripts (UTC only)
        if (!isBic)
        {
            AppendScriptsSectionMd(sb, creature);
        }

        // Footer
        sb.AppendLine("---");
        sb.AppendLine($"*Generated by Quartermaster on {DateTime.Now:yyyy-MM-dd HH:mm}*");

        return sb.ToString();
    }

    #region Text Format Sections

    private void AppendIdentitySection(StringBuilder sb, UtcFile creature, bool isBic)
    {
        sb.AppendLine("IDENTITY");
        sb.AppendLine("───────────────────────────────────────────────────────────────");

        var raceName = _displayService.GetRaceName(creature.Race);
        var genderName = _displayService.GetGenderName(creature.Gender);
        var alignment = GetAlignmentName(creature.GoodEvil, creature.LawfulChaotic);

        sb.AppendLine($"  Race:      {raceName}");
        sb.AppendLine($"  Gender:    {genderName}");
        sb.AppendLine($"  Alignment: {alignment} (G/E: {creature.GoodEvil}, L/C: {creature.LawfulChaotic})");

        if (!string.IsNullOrEmpty(creature.Subrace))
            sb.AppendLine($"  Subrace:   {creature.Subrace}");

        if (!string.IsNullOrEmpty(creature.Deity))
            sb.AppendLine($"  Deity:     {creature.Deity}");

        sb.AppendLine();

        if (!string.IsNullOrEmpty(creature.Tag))
            sb.AppendLine($"  Tag:       {creature.Tag}");

        if (!string.IsNullOrEmpty(creature.TemplateResRef))
            sb.AppendLine($"  ResRef:    {creature.TemplateResRef}");

        if (isBic && creature is BicFile bicFile && bicFile.Experience > 0)
            sb.AppendLine($"  XP:        {bicFile.Experience:N0}");

        sb.AppendLine();
    }

    private void AppendClassSection(StringBuilder sb, UtcFile creature)
    {
        sb.AppendLine("CLASS PROGRESSION");
        sb.AppendLine("───────────────────────────────────────────────────────────────");

        var totalLevel = creature.ClassList.Sum(c => c.ClassLevel);
        var classStrings = creature.ClassList
            .Select(c => $"{_displayService.GetClassName(c.Class)} {c.ClassLevel}")
            .ToList();

        sb.AppendLine($"  {string.Join(" / ", classStrings)}");
        sb.AppendLine($"  Total Level: {totalLevel}");
        sb.AppendLine();

        // Class details
        foreach (var c in creature.ClassList)
        {
            var hitDie = _displayService.GetClassHitDie(c.Class);
            var skillPts = _displayService.GetClassSkillPointBase(c.Class);
            sb.AppendLine($"  {_displayService.GetClassName(c.Class)}:");
            sb.AppendLine($"    Level {c.ClassLevel}, {hitDie}, {skillPts} skill pts/lvl");
        }

        sb.AppendLine();
    }

    private void AppendAbilitySection(StringBuilder sb, UtcFile creature)
    {
        sb.AppendLine("ABILITY SCORES");
        sb.AppendLine("───────────────────────────────────────────────────────────────");

        var racialMods = _displayService.GetRacialModifiers(creature.Race);

        sb.AppendLine("  Ability    Base    Racial    Final    Modifier");
        sb.AppendLine("  ─────────────────────────────────────────────────");

        AppendAbilityRow(sb, "STR", creature.Str, racialMods.Str);
        AppendAbilityRow(sb, "DEX", creature.Dex, racialMods.Dex);
        AppendAbilityRow(sb, "CON", creature.Con, racialMods.Con);
        AppendAbilityRow(sb, "INT", creature.Int, racialMods.Int);
        AppendAbilityRow(sb, "WIS", creature.Wis, racialMods.Wis);
        AppendAbilityRow(sb, "CHA", creature.Cha, racialMods.Cha);

        sb.AppendLine();
    }

    private static void AppendAbilityRow(StringBuilder sb, string name, byte score, int racialMod)
    {
        var baseScore = score; // Note: UTC stores final scores, not base
        var modifier = CreatureDisplayService.CalculateAbilityBonus(score);
        var modStr = CreatureDisplayService.FormatBonus(modifier);
        var racialStr = racialMod != 0 ? CreatureDisplayService.FormatBonus(racialMod) : "  -";

        sb.AppendLine($"  {name,-8}  {baseScore,4}    {racialStr,6}    {score,5}    {modStr,8}");
    }

    private void AppendCombatSection(StringBuilder sb, UtcFile creature)
    {
        sb.AppendLine("COMBAT STATISTICS");
        sb.AppendLine("───────────────────────────────────────────────────────────────");

        var bab = _displayService.CalculateBaseAttackBonus(creature);
        var conMod = CreatureDisplayService.CalculateAbilityBonus(creature.Con);
        var dexMod = CreatureDisplayService.CalculateAbilityBonus(creature.Dex);
        var wisMod = CreatureDisplayService.CalculateAbilityBonus(creature.Wis);

        // HP - stored as CurrentHitPoints and MaxHitPoints in UTC
        sb.AppendLine($"  Hit Points:    {creature.CurrentHitPoints} / {creature.MaxHitPoints}");
        sb.AppendLine($"  Base AC:       {creature.NaturalAC} (Natural AC)");
        sb.AppendLine($"  BAB:           {CreatureDisplayService.FormatBonus(bab)}");
        sb.AppendLine();

        // Saves (base values from UTC)
        sb.AppendLine($"  Fortitude:     {CreatureDisplayService.FormatBonus(creature.FortBonus)} (base) {CreatureDisplayService.FormatBonus(conMod)} (CON)");
        sb.AppendLine($"  Reflex:        {CreatureDisplayService.FormatBonus(creature.RefBonus)} (base) {CreatureDisplayService.FormatBonus(dexMod)} (DEX)");
        sb.AppendLine($"  Will:          {CreatureDisplayService.FormatBonus(creature.WillBonus)} (base) {CreatureDisplayService.FormatBonus(wisMod)} (WIS)");

        sb.AppendLine();
    }

    private void AppendSkillsSection(StringBuilder sb, UtcFile creature)
    {
        sb.AppendLine("SKILLS");
        sb.AppendLine("───────────────────────────────────────────────────────────────");

        var classSkills = _displayService.GetCombinedClassSkillIds(creature);

        sb.AppendLine("  Skill                  Ranks  Ability  Class?");
        sb.AppendLine("  ─────────────────────────────────────────────────");

        for (int i = 0; i < creature.SkillList.Count; i++)
        {
            var ranks = creature.SkillList[i];
            if (ranks == 0) continue; // Skip untrained skills

            var skillName = _displayService.GetSkillName(i);
            var keyAbility = _displayService.GetSkillKeyAbility(i);
            var isClass = classSkills.Contains(i) ? "Yes" : " - ";

            sb.AppendLine($"  {skillName,-22} {ranks,5}  {keyAbility,-7}  {isClass}");
        }

        sb.AppendLine();
    }

    private void AppendFeatsSection(StringBuilder sb, UtcFile creature)
    {
        sb.AppendLine("FEATS");
        sb.AppendLine("───────────────────────────────────────────────────────────────");

        if (creature.FeatList.Count == 0)
        {
            sb.AppendLine("  (No feats)");
            sb.AppendLine();
            return;
        }

        // Group by category
        var featsByCategory = creature.FeatList
            .Select(featId => new { Id = featId, Info = _displayService.GetFeatInfo(featId) })
            .GroupBy(f => f.Info.Category)
            .OrderBy(g => g.Key);

        foreach (var group in featsByCategory)
        {
            var categoryName = group.Key switch
            {
                FeatCategory.Combat => "Combat",
                FeatCategory.ActiveCombat => "Active Combat",
                FeatCategory.Defensive => "Defensive",
                FeatCategory.Magical => "Magical",
                FeatCategory.ClassRacial => "Class/Racial",
                _ => "Other"
            };

            sb.AppendLine($"  [{categoryName}]");
            foreach (var feat in group.OrderBy(f => f.Info.Name))
            {
                sb.AppendLine($"    • {feat.Info.Name}");
            }
        }

        sb.AppendLine();
    }

    private void AppendSpellsSection(StringBuilder sb, UtcFile creature)
    {
        // Check if creature has any spellcasting classes
        var hasCasterClass = creature.ClassList.Any(c => _displayService.IsCasterClass(c.Class));
        if (!hasCasterClass) return;

        sb.AppendLine("SPELLS");
        sb.AppendLine("───────────────────────────────────────────────────────────────");

        // Known spells per class
        for (int classIndex = 0; classIndex < creature.ClassList.Count; classIndex++)
        {
            var creatureClass = creature.ClassList[classIndex];
            if (!_displayService.IsCasterClass(creatureClass.Class)) continue;

            var className = _displayService.GetClassName(creatureClass.Class);
            sb.AppendLine($"  {className} Spells:");

            // Get spells known for this class index
            var spellsKnown = GetSpellsKnownForClass(creature, classIndex);
            if (spellsKnown.Count == 0)
            {
                sb.AppendLine("    (No spells known)");
                continue;
            }

            // Group by spell level
            var byLevel = spellsKnown
                .GroupBy(s => s.Level)
                .OrderBy(g => g.Key);

            foreach (var levelGroup in byLevel)
            {
                sb.AppendLine($"    Level {levelGroup.Key}:");
                foreach (var spell in levelGroup.OrderBy(s => s.Name))
                {
                    sb.AppendLine($"      • {spell.Name}");
                }
            }
        }

        sb.AppendLine();
    }

    private void AppendEquipmentSection(StringBuilder sb, UtcFile creature)
    {
        sb.AppendLine("EQUIPMENT");
        sb.AppendLine("───────────────────────────────────────────────────────────────");

        if (creature.EquipItemList.Count == 0)
        {
            sb.AppendLine("  (No equipped items)");
            sb.AppendLine();
            return;
        }

        var slotNames = new Dictionary<int, string>
        {
            { 0, "Head" }, { 1, "Chest" }, { 2, "Boots" }, { 3, "Arms" },
            { 4, "Right Hand" }, { 5, "Left Hand" }, { 6, "Cloak" },
            { 7, "Left Ring" }, { 8, "Right Ring" }, { 9, "Neck" },
            { 10, "Belt" }, { 11, "Arrows" }, { 12, "Bullets" },
            { 13, "Bolts" }, { 14, "Creature Left" }, { 15, "Creature Right" },
            { 16, "Creature Bite" }, { 17, "Creature Armor" }
        };

        foreach (var equip in creature.EquipItemList.OrderBy(e => e.Slot))
        {
            var slotName = EquipmentSlots.GetSlotName(equip.Slot);
            var itemName = !string.IsNullOrEmpty(equip.EquipRes) ? equip.EquipRes : "(Unknown)";
            sb.AppendLine($"  {slotName,-15}: {itemName}");
        }

        sb.AppendLine();

        // Gold (BIC only)
        if (creature is BicFile bicForGold)
            sb.AppendLine($"  Gold: {bicForGold.Gold:N0}");
        sb.AppendLine();
    }

    private void AppendScriptsSection(StringBuilder sb, UtcFile creature)
    {
        sb.AppendLine("SCRIPTS");
        sb.AppendLine("───────────────────────────────────────────────────────────────");

        var scripts = new[]
        {
            ("OnHeartbeat", creature.ScriptHeartbeat),
            ("OnPerception", creature.ScriptOnNotice),
            ("OnSpellCast", creature.ScriptSpellAt),
            ("OnAttacked", creature.ScriptAttacked),
            ("OnDamaged", creature.ScriptDamaged),
            ("OnDisturbed", creature.ScriptDisturbed),
            ("OnCombatEnd", creature.ScriptEndRound),
            ("OnConversation", creature.ScriptDialogue),
            ("OnSpawn", creature.ScriptSpawn),
            ("OnRested", creature.ScriptRested),
            ("OnDeath", creature.ScriptDeath),
            ("OnUserDefined", creature.ScriptUserDefine),
            ("OnBlocked", creature.ScriptOnBlocked)
        };

        var hasScripts = false;
        foreach (var (name, script) in scripts)
        {
            if (!string.IsNullOrEmpty(script))
            {
                sb.AppendLine($"  {name,-15}: {script}");
                hasScripts = true;
            }
        }

        if (!hasScripts)
            sb.AppendLine("  (No scripts assigned)");

        sb.AppendLine();
    }

    #endregion

    #region Markdown Format Sections

    private void AppendIdentitySectionMd(StringBuilder sb, UtcFile creature, bool isBic)
    {
        sb.AppendLine("## Identity");
        sb.AppendLine();

        var raceName = _displayService.GetRaceName(creature.Race);
        var genderName = _displayService.GetGenderName(creature.Gender);
        var alignment = GetAlignmentName(creature.GoodEvil, creature.LawfulChaotic);

        sb.AppendLine($"- **Race:** {raceName}");
        sb.AppendLine($"- **Gender:** {genderName}");
        sb.AppendLine($"- **Alignment:** {alignment} (G/E: {creature.GoodEvil}, L/C: {creature.LawfulChaotic})");

        if (!string.IsNullOrEmpty(creature.Subrace))
            sb.AppendLine($"- **Subrace:** {creature.Subrace}");

        if (!string.IsNullOrEmpty(creature.Deity))
            sb.AppendLine($"- **Deity:** {creature.Deity}");

        if (!string.IsNullOrEmpty(creature.Tag))
            sb.AppendLine($"- **Tag:** `{creature.Tag}`");

        if (!string.IsNullOrEmpty(creature.TemplateResRef))
            sb.AppendLine($"- **ResRef:** `{creature.TemplateResRef}`");

        if (isBic && creature is BicFile bicFile && bicFile.Experience > 0)
            sb.AppendLine($"- **XP:** {bicFile.Experience:N0}");

        sb.AppendLine();
    }

    private void AppendClassSectionMd(StringBuilder sb, UtcFile creature)
    {
        sb.AppendLine("## Class Progression");
        sb.AppendLine();

        var totalLevel = creature.ClassList.Sum(c => c.ClassLevel);
        var classStrings = creature.ClassList
            .Select(c => $"**{_displayService.GetClassName(c.Class)}** {c.ClassLevel}")
            .ToList();

        sb.AppendLine($"{string.Join(" / ", classStrings)} (Total: {totalLevel})");
        sb.AppendLine();

        sb.AppendLine("| Class | Level | Hit Die | Skill Points |");
        sb.AppendLine("|-------|-------|---------|--------------|");

        foreach (var c in creature.ClassList)
        {
            var className = _displayService.GetClassName(c.Class);
            var hitDie = _displayService.GetClassHitDie(c.Class);
            var skillPts = _displayService.GetClassSkillPointBase(c.Class);
            sb.AppendLine($"| {className} | {c.ClassLevel} | {hitDie} | {skillPts}/lvl |");
        }

        sb.AppendLine();
    }

    private void AppendAbilitySectionMd(StringBuilder sb, UtcFile creature)
    {
        sb.AppendLine("## Ability Scores");
        sb.AppendLine();

        sb.AppendLine("| Ability | Score | Modifier |");
        sb.AppendLine("|---------|-------|----------|");

        AppendAbilityRowMd(sb, "STR", creature.Str);
        AppendAbilityRowMd(sb, "DEX", creature.Dex);
        AppendAbilityRowMd(sb, "CON", creature.Con);
        AppendAbilityRowMd(sb, "INT", creature.Int);
        AppendAbilityRowMd(sb, "WIS", creature.Wis);
        AppendAbilityRowMd(sb, "CHA", creature.Cha);

        sb.AppendLine();
    }

    private static void AppendAbilityRowMd(StringBuilder sb, string name, byte score)
    {
        var modifier = CreatureDisplayService.CalculateAbilityBonus(score);
        var modStr = CreatureDisplayService.FormatBonus(modifier);
        sb.AppendLine($"| {name} | {score} | {modStr} |");
    }

    private void AppendCombatSectionMd(StringBuilder sb, UtcFile creature)
    {
        sb.AppendLine("## Combat Statistics");
        sb.AppendLine();

        var bab = _displayService.CalculateBaseAttackBonus(creature);

        sb.AppendLine($"- **Hit Points:** {creature.CurrentHitPoints} / {creature.MaxHitPoints}");
        sb.AppendLine($"- **Natural AC:** {creature.NaturalAC}");
        sb.AppendLine($"- **BAB:** {CreatureDisplayService.FormatBonus(bab)}");
        sb.AppendLine();

        sb.AppendLine("### Saving Throws");
        sb.AppendLine();
        sb.AppendLine($"- **Fortitude:** {CreatureDisplayService.FormatBonus(creature.FortBonus)} (base)");
        sb.AppendLine($"- **Reflex:** {CreatureDisplayService.FormatBonus(creature.RefBonus)} (base)");
        sb.AppendLine($"- **Will:** {CreatureDisplayService.FormatBonus(creature.WillBonus)} (base)");
        sb.AppendLine();
    }

    private void AppendSkillsSectionMd(StringBuilder sb, UtcFile creature)
    {
        sb.AppendLine("## Skills");
        sb.AppendLine();

        var classSkills = _displayService.GetCombinedClassSkillIds(creature);
        var trainedSkills = new List<(int Id, byte Ranks)>();

        for (int i = 0; i < creature.SkillList.Count; i++)
        {
            if (creature.SkillList[i] > 0)
                trainedSkills.Add((i, creature.SkillList[i]));
        }

        if (trainedSkills.Count == 0)
        {
            sb.AppendLine("*No trained skills*");
            sb.AppendLine();
            return;
        }

        sb.AppendLine("| Skill | Ranks | Ability | Class? |");
        sb.AppendLine("|-------|-------|---------|--------|");

        foreach (var (skillId, ranks) in trainedSkills.OrderByDescending(s => s.Ranks))
        {
            var skillName = _displayService.GetSkillName(skillId);
            var keyAbility = _displayService.GetSkillKeyAbility(skillId);
            var isClass = classSkills.Contains(skillId) ? "✓" : "-";

            sb.AppendLine($"| {skillName} | {ranks} | {keyAbility} | {isClass} |");
        }

        sb.AppendLine();
    }

    private void AppendFeatsSectionMd(StringBuilder sb, UtcFile creature)
    {
        sb.AppendLine("## Feats");
        sb.AppendLine();

        if (creature.FeatList.Count == 0)
        {
            sb.AppendLine("*No feats*");
            sb.AppendLine();
            return;
        }

        var featsByCategory = creature.FeatList
            .Select(featId => new { Id = featId, Info = _displayService.GetFeatInfo(featId) })
            .GroupBy(f => f.Info.Category)
            .OrderBy(g => g.Key);

        foreach (var group in featsByCategory)
        {
            var categoryName = group.Key switch
            {
                FeatCategory.Combat => "Combat",
                FeatCategory.ActiveCombat => "Active Combat",
                FeatCategory.Defensive => "Defensive",
                FeatCategory.Magical => "Magical",
                FeatCategory.ClassRacial => "Class/Racial",
                _ => "Other"
            };

            sb.AppendLine($"### {categoryName}");
            sb.AppendLine();
            foreach (var feat in group.OrderBy(f => f.Info.Name))
            {
                sb.AppendLine($"- {feat.Info.Name}");
            }
            sb.AppendLine();
        }
    }

    private void AppendSpellsSectionMd(StringBuilder sb, UtcFile creature)
    {
        var hasCasterClass = creature.ClassList.Any(c => _displayService.IsCasterClass(c.Class));
        if (!hasCasterClass) return;

        sb.AppendLine("## Spells");
        sb.AppendLine();

        for (int classIndex = 0; classIndex < creature.ClassList.Count; classIndex++)
        {
            var creatureClass = creature.ClassList[classIndex];
            if (!_displayService.IsCasterClass(creatureClass.Class)) continue;

            var className = _displayService.GetClassName(creatureClass.Class);
            sb.AppendLine($"### {className}");
            sb.AppendLine();

            var spellsKnown = GetSpellsKnownForClass(creature, classIndex);
            if (spellsKnown.Count == 0)
            {
                sb.AppendLine("*No spells known*");
                sb.AppendLine();
                continue;
            }

            var byLevel = spellsKnown.GroupBy(s => s.Level).OrderBy(g => g.Key);

            foreach (var levelGroup in byLevel)
            {
                sb.AppendLine($"**Level {levelGroup.Key}:** {string.Join(", ", levelGroup.OrderBy(s => s.Name).Select(s => s.Name))}");
            }
            sb.AppendLine();
        }
    }

    private void AppendEquipmentSectionMd(StringBuilder sb, UtcFile creature)
    {
        sb.AppendLine("## Equipment");
        sb.AppendLine();

        if (creature.EquipItemList.Count == 0)
        {
            sb.AppendLine("*No equipped items*");
            sb.AppendLine();
            return;
        }

        var slotNames = new Dictionary<int, string>
        {
            { 0, "Head" }, { 1, "Chest" }, { 2, "Boots" }, { 3, "Arms" },
            { 4, "Right Hand" }, { 5, "Left Hand" }, { 6, "Cloak" },
            { 7, "Left Ring" }, { 8, "Right Ring" }, { 9, "Neck" },
            { 10, "Belt" }, { 11, "Arrows" }, { 12, "Bullets" },
            { 13, "Bolts" }, { 14, "Creature Left" }, { 15, "Creature Right" },
            { 16, "Creature Bite" }, { 17, "Creature Armor" }
        };

        sb.AppendLine("| Slot | Item |");
        sb.AppendLine("|------|------|");

        foreach (var equip in creature.EquipItemList.OrderBy(e => e.Slot))
        {
            var slotName = EquipmentSlots.GetSlotName(equip.Slot);
            var itemName = !string.IsNullOrEmpty(equip.EquipRes) ? equip.EquipRes : "(Unknown)";
            sb.AppendLine($"| {slotName} | {itemName} |");
        }

        sb.AppendLine();
        // Gold (BIC only)
        if (creature is BicFile bicForGold)
            sb.AppendLine($"**Gold:** {bicForGold.Gold:N0}");
        sb.AppendLine();
    }

    private void AppendScriptsSectionMd(StringBuilder sb, UtcFile creature)
    {
        sb.AppendLine("## Scripts");
        sb.AppendLine();

        var scripts = new[]
        {
            ("OnHeartbeat", creature.ScriptHeartbeat),
            ("OnPerception", creature.ScriptOnNotice),
            ("OnSpellCast", creature.ScriptSpellAt),
            ("OnAttacked", creature.ScriptAttacked),
            ("OnDamaged", creature.ScriptDamaged),
            ("OnDisturbed", creature.ScriptDisturbed),
            ("OnCombatEnd", creature.ScriptEndRound),
            ("OnConversation", creature.ScriptDialogue),
            ("OnSpawn", creature.ScriptSpawn),
            ("OnRested", creature.ScriptRested),
            ("OnDeath", creature.ScriptDeath),
            ("OnUserDefined", creature.ScriptUserDefine),
            ("OnBlocked", creature.ScriptOnBlocked)
        };

        var hasScripts = scripts.Any(s => !string.IsNullOrEmpty(s.Item2));
        if (!hasScripts)
        {
            sb.AppendLine("*No scripts assigned*");
            sb.AppendLine();
            return;
        }

        sb.AppendLine("| Event | Script |");
        sb.AppendLine("|-------|--------|");

        foreach (var (eventName, script) in scripts)
        {
            if (!string.IsNullOrEmpty(script))
            {
                sb.AppendLine($"| {eventName} | `{script}` |");
            }
        }

        sb.AppendLine();
    }

    #endregion

    #region Helper Methods

    private static string GetAlignmentName(byte goodEvil, byte lawChaotic)
    {
        var geAxis = goodEvil switch
        {
            >= 70 => "Good",
            <= 30 => "Evil",
            _ => "Neutral"
        };

        var lcAxis = lawChaotic switch
        {
            >= 70 => "Lawful",
            <= 30 => "Chaotic",
            _ => "Neutral"
        };

        if (geAxis == "Neutral" && lcAxis == "Neutral")
            return "True Neutral";

        return $"{lcAxis} {geAxis}";
    }

    private List<(string Name, int Level)> GetSpellsKnownForClass(UtcFile creature, int classIndex)
    {
        var result = new List<(string Name, int Level)>();

        if (classIndex >= creature.ClassList.Count)
            return result;

        var creatureClass = creature.ClassList[classIndex];

        // KnownSpells is an array of lists, indexed by spell level 0-9
        for (int spellLevel = 0; spellLevel < creatureClass.KnownSpells.Length; spellLevel++)
        {
            var spellsAtLevel = creatureClass.KnownSpells[spellLevel];
            foreach (var knownSpell in spellsAtLevel)
            {
                var spellName = _displayService.GetSpellName((int)knownSpell.Spell);
                result.Add((spellName, spellLevel));
            }
        }

        return result;
    }

    #endregion
}
